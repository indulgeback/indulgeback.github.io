import{_ as s,c as a,G as i,b as n}from"./chunks/framework.BrC0DRXd.js";const l=JSON.parse('{"title":"V8垃圾回收与GC算法","description":"介绍了V8垃圾回收与GC算法","frontmatter":{"title":"V8垃圾回收与GC算法","date":"2023-09-29T00:00:00.000Z","author":"liuwy","categories":["内功"],"tags":["V8引擎"],"description":"介绍了V8垃圾回收与GC算法","articleGPT":"介绍了V8垃圾回收与GC算法，包括标记清除算法、标记整理算法、分代回收算法等。","head":[["link",{"rel":"canonical","href":"https://blog.imsyy.top/posts/技术内功/2、V8垃圾回收与GC算法"}]]},"headers":[],"relativePath":"posts/技术内功/2、V8垃圾回收与GC算法.md","filePath":"posts/技术内功/2、V8垃圾回收与GC算法.md","lastUpdated":1740135853000}');const e=s({name:"posts/技术内功/2、V8垃圾回收与GC算法.md"},[["render",function(s,l,e,p,t,h){return n(),a("div",null,l[0]||(l[0]=[i('<h1 id="v8垃圾回收与gc算法" tabindex="-1">V8垃圾回收与GC算法 <a class="header-anchor" href="#v8垃圾回收与gc算法" aria-label="Permalink to &quot;V8垃圾回收与GC算法&quot;">​</a></h1><blockquote><p>内存管理</p><ul><li>内存：由可读写单元组成， 表示一片可操作空间</li><li>管理：人为的去操作一片空间的申请、使用和释放</li><li>内存管理：开发者主动申请空间、使用空间、释放</li><li>空间管理流程：申请一使用一释放</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 申请内存空间</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用内存空间</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;lg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 释放内存空间</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></blockquote><h2 id="什么是垃圾" tabindex="-1">什么是垃圾 <a class="header-anchor" href="#什么是垃圾" aria-label="Permalink to &quot;什么是垃圾&quot;">​</a></h2><h3 id="javascript-中的垃圾" tabindex="-1">JavaScript 中的垃圾 <a class="header-anchor" href="#javascript-中的垃圾" aria-label="Permalink to &quot;JavaScript 中的垃圾&quot;">​</a></h3><ul><li>JavaScript 中内存管理是自动的</li><li>对象不再被引用时是垃圾</li><li>对象不能从根上访问到时是垃圾</li></ul><h3 id="javascript-中的可达对象" tabindex="-1">JavaScript 中的可达对象 <a class="header-anchor" href="#javascript-中的可达对象" aria-label="Permalink to &quot;JavaScript 中的可达对象&quot;">​</a></h3><ul><li>可以访问到的对象就是可达对象 (引用、作用域链)</li><li>可达的标准就是从根出发是否能够被找到</li><li>JavaScript 中的根就可以理解为是全局变量对象</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> objGroup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  obj.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj2;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  obj2.prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj1;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { o1: obj1, o2: obj2 };</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> objgroup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;obj1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;obj2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="常用gc-garbage-collection-策略" tabindex="-1">常用GC（Garbage Collection）策略 <a class="header-anchor" href="#常用gc-garbage-collection-策略" aria-label="Permalink to &quot;常用GC（Garbage Collection）策略&quot;">​</a></h2><h3 id="标记清除-mark-sweep" tabindex="-1">标记清除（Mark-Sweep） <a class="header-anchor" href="#标记清除-mark-sweep" aria-label="Permalink to &quot;标记清除（Mark-Sweep）&quot;">​</a></h3><blockquote><p>标记清除算法的核心主要分为两部分：标记和清除</p></blockquote><h4 id="标记" tabindex="-1">标记 <a class="header-anchor" href="#标记" aria-label="Permalink to &quot;标记&quot;">​</a></h4><p>标记所有活着的对象（即不是垃圾的对象，如上提到的可达对象（可以访问到的对象））</p><h4 id="清除" tabindex="-1">清除 <a class="header-anchor" href="#清除" aria-label="Permalink to &quot;清除&quot;">​</a></h4><p>清除所有没有被标记的对象</p><h4 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h4><p>思路简单，易于实现</p><h4 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><p>由于标记到的对象肯定不是连续的内存空间，所以会增加可用内存空间的颗粒度，当然，V8引擎对此做了优化，我们下面就会讲到。还有一个问题就是用标记清除算法执行垃圾清理的时候会暂停程序的运行，由于JS的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会再次恢复执行主任务的逻辑，这种行为被称为<code>全停顿(stop-the-world)</code>，这个现象在下面也有相应的解决方法。</p><p>![image-20240918143941775](/Users/leviliu/Library/Application Support/typora-user-images/image-20240918143941775.png)</p><p>由于空间碎片化增大，会导致新的对象可能很难找到空间放进内存，之间的计算过程也是一部分额外开销。</p><p>![image-20240918143958117](/Users/leviliu/Library/Application Support/typora-user-images/image-20240918143958117.png)</p><h3 id="引用计数" tabindex="-1">引用计数 <a class="header-anchor" href="#引用计数" aria-label="Permalink to &quot;引用计数&quot;">​</a></h3><blockquote><p>引用计数的过程是：当有一个引用类型的值被赋值给一个变量的值时，那么它的引用次数就加一，而当该变量的值指向了其他引用类型的值时，它的引用次数就减一，而当引用次数变成0的时候，就会被立即回收。</p></blockquote><h4 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点&quot;">​</a></h4><ul><li>实时回收，引用计数当归零就立即进行回收操作。</li><li>不会暂停执行栈，标记清除算法定时进行垃圾回收时会先暂停程序运行，来进行垃圾回收，而引用计数是实时回收不会暂停程序的运行</li></ul><h4 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ul><li>空间开销：在进行引用计数算法时需要有空间来存放计数</li><li>性能开销：由于是实时清理，所以在程序运行中也会产生一定的性能开销</li><li>无法解决循环引用问题：如果有A的属性引用B，B的属性引用A，那么两者的引用计数基数都不为零，所以永远都不会被回收掉</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="v8引擎对gc的优化" tabindex="-1">V8引擎对GC的优化 <a class="header-anchor" href="#v8引擎对gc的优化" aria-label="Permalink to &quot;V8引擎对GC的优化&quot;">​</a></h2><blockquote><p>之前GC的清除算法无论是标记清除还是标记整理，在进行回收时都需要检查内存中的所有对象，但是如果存在一些，体积大，存活时间长，创建早的内存来进行检查，相当于是做了无用功，而新创建，体积小和存活时间短的对象需要更加频繁的检查所以基于这个问题V8提出了新生代和老生代的优化策略。将内存空间划分为新生代和老生代两个部分，不同部分执行不同的回收策略。</p></blockquote><p>![image-20240918144015123](/Users/leviliu/Library/Application Support/typora-user-images/image-20240918144015123.png)</p><h3 id="分代式优化" tabindex="-1">分代式优化 <a class="header-anchor" href="#分代式优化" aria-label="Permalink to &quot;分代式优化&quot;">​</a></h3><h4 id="新生代" tabindex="-1">新生代 <a class="header-anchor" href="#新生代" aria-label="Permalink to &quot;新生代&quot;">​</a></h4><p>新生代中的对象主要通过 Scavenge 算法进行垃圾回收。这是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间成为 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间。</p><p><a class="img-fancybox" href="data:image/webp;base64,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" data-fancybox="gallery" data-caption="img"><img class="post-img" src="data:image/webp;base64,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" alt="img" loading="lazy"><span class="post-img-tip">img</span></a></p><ul><li>当开始垃圾回收的时候，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间发生角色对换。</li><li>因为新生代中对象的生命周期比较短，就比较适合这个算法。</li><li>当一个对象经过多次复制依然存活，它将会被认为是生命周期较长的对象。这种新生代中生命周期较长的对象随后会被移到老生代中。</li><li>不过还需要注意一个特殊情况，比如新生代复制一个对象到To空间，此时如果To的使用空间超过25%之后这个对象会被立即复制到老生代，而25%的红线要求是为了保证进行To和From翻转时对于新的对象分配空间操作不会被影响。</li></ul><h4 id="老生代" tabindex="-1">老生代 <a class="header-anchor" href="#老生代" aria-label="Permalink to &quot;老生代&quot;">​</a></h4><p>老生代主要采取的是标记清除的垃圾回收算法。与 Scavenge 复制活着的对象不同，标记清除算法在标记阶段遍历堆中的所有对象，并标记活着的对象，只清理死亡对象。活对象在新生代中只占叫小部分，死对象在老生代中只占较小部分，这是为什么采用标记清除算法的原因。</p><h3 id="对象晋升-object-promotion" tabindex="-1">对象晋升（Object-Promotion） <a class="header-anchor" href="#对象晋升-object-promotion" aria-label="Permalink to &quot;对象晋升（Object-Promotion）&quot;">​</a></h3><p>上文中有提到<code>当一个对象经过多次复制依然存活，它将会被认为是生命周期较长的对象。这种新生代中生命周期较长的对象随后会被移到老生代中。</code>这个现象我们就称之为对象晋升，对象晋升的两个主要条件如下：</p><ul><li>对象是否经历过一次<code>Scavenge</code>算法</li><li><code>To</code>空间的内存占比是否已经超过<code>25%</code></li></ul><p>两个判断条件的流程图如下：</p><p><a class="img-fancybox" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/8/16ee3c5634e61f9e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" data-fancybox="gallery" data-caption="img"><img class="post-img" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/8/16ee3c5634e61f9e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img" loading="lazy"><span class="post-img-tip">img</span></a></p><p><a class="img-fancybox" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/8/16ee3c90fedad146~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" data-fancybox="gallery" data-caption="img"><img class="post-img" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/8/16ee3c90fedad146~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img" loading="lazy"><span class="post-img-tip">img</span></a></p><h3 id="标记整理-mark-compact" tabindex="-1">标记整理（Mark-Compact） <a class="header-anchor" href="#标记整理-mark-compact" aria-label="Permalink to &quot;标记整理（Mark-Compact）&quot;">​</a></h3><p>上文中我们有提到过在进行标记清除（Mark-Sweep）算法之后会出现内存空间碎片化严重的现象，针对这种现象<code>标记整理（Mark-Compact）</code>被提了出来，该算法主要就是用来解决内存的碎片化问题的，回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存。具体表示如下：</p><ul><li>假设在老生代中有A、B、C、D四个对象</li></ul><p><a class="img-fancybox" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/8/16ee47d9f933bfc1~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" data-fancybox="gallery" data-caption="img"><img class="post-img" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/8/16ee47d9f933bfc1~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img" loading="lazy"><span class="post-img-tip">img</span></a></p><ul><li>在垃圾回收的<code>标记</code>阶段，将对象A和对象C标记为活动的</li></ul><p><a class="img-fancybox" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/8/16ee486ece5fda42~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" data-fancybox="gallery" data-caption="img"><img class="post-img" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/8/16ee486ece5fda42~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img" loading="lazy"><span class="post-img-tip">img</span></a></p><ul><li>在垃圾回收的<code>整理</code>阶段，将活动的对象往堆内存的一端移动</li></ul><p><a class="img-fancybox" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/8/16ee48f23fe98d7a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" data-fancybox="gallery" data-caption="img"><img class="post-img" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/8/16ee48f23fe98d7a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img" loading="lazy"><span class="post-img-tip">img</span></a></p><ul><li>在垃圾回收的<code>清除</code>阶段，将活动对象左侧的内存全部回收</li></ul><p><a class="img-fancybox" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/8/16ee490a8b9bf0af~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" data-fancybox="gallery" data-caption="img"><img class="post-img" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/8/16ee490a8b9bf0af~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img" loading="lazy"><span class="post-img-tip">img</span></a></p><h3 id="增量标记-incremental-marking" tabindex="-1">增量标记（Incremental-Marking） <a class="header-anchor" href="#增量标记-incremental-marking" aria-label="Permalink to &quot;增量标记（Incremental-Marking）&quot;">​</a></h3><p>上文中有提到，在进行标记清除算法时，垃圾回收的过程会影响JS主线程的执行，这就会造成<code>全停顿</code>的，针对这一现象，V8引擎又引入了增量标记的概念，即将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。</p><p>该方法有点类似于React的fiber架构，即在浏览器渲染帧空闲时间遍历Fiber Tree中的任务，这样就可以防止阻塞主线程的任务，实现方式比较类似于 requestIdleCallback 这个API，但是fiber并非用它实现。</p><h4 id="三色标记法-恢复与暂停" tabindex="-1">三色标记法（恢复与暂停） <a class="header-anchor" href="#三色标记法-恢复与暂停" aria-label="Permalink to &quot;三色标记法（恢复与暂停）&quot;">​</a></h4><p>在引入三色标记法之前的GC标记只是将活动的变量标记为黑色，不活动的变量标记为白色，当GC标记过程结束之后，系统会回收掉所有的白色标记变量，但是这种非黑即白的方法虽然清除起来非常方便但是存在一个问题执行一段时间之后无法知道执行到了哪里，不能进行暂停。所以V8又引入了一个灰色进行暂停和恢复操作。</p><p>![image-20240918144034669](/Users/leviliu/Library/Application Support/typora-user-images/image-20240918144034669.png)</p><p>如图所示，在GC标记开始时所有对象都是白色的，然后从根对象开始进行标记，先将这组对象标记为灰色然后进行记录，如果此时进行中断，后续恢复时既从灰色标记时开始即可，当回收器从标记工作表中弹出对象并访问他们的引用对象时，会将灰色置为黑色，同时将下一个引用对象置为灰色，继续往下进行标记工作。直至无可标记为灰色对象为止，此时表示GC标记过程结束，将所有未标记的变量进行回收工作。所以三色标记法可以渐进执行而不用每次执行都要全盘进行扫描整个内存空间，可以配合增量回收减少全停顿时间，提升体验。</p><h4 id="写屏障" tabindex="-1">写屏障 <a class="header-anchor" href="#写屏障" aria-label="Permalink to &quot;写屏障&quot;">​</a></h4><p>![image-20240918144048439](/Users/leviliu/Library/Application Support/typora-user-images/image-20240918144048439.png)</p><p>![image-20240918144104692](/Users/leviliu/Library/Application Support/typora-user-images/image-20240918144104692.png)</p><p>如图所示，现有A、B、C三个对象依次被引用，且在GC过程中已经被标记了，但是在暂停GC任务，插入执行程序任务之后，引用关系被改变了，新增了一个新变量D，但是此时程序中也未存在灰色标记的变量，下一步进行清除机制时，新变量D按清除机制来讲是要被清除掉，但是这是极其不合理的，一个新的变量还存在引用就被回收掉，这会导致程序云行报错。此时写屏障机制就派上用场了，一旦有黑色的对象引用白色的对象，就会强制将被引用的白色变量标记为灰色，保证下一次的增量GC正确运行，这个机制称为强三色不变性(白色变量D被黑色变量B引用之后会被强制置灰保证程序运行正确性)。</p><h4 id="惰性清理" tabindex="-1">惰性清理 <a class="header-anchor" href="#惰性清理" aria-label="Permalink to &quot;惰性清理&quot;">​</a></h4><p>在增量GC标记之后下一步就是来真正回收内存空间，通过惰性清理来进行清除释放内存。惰性清理机制运行原理是在进行回收时如果内存足够就可以将这个回收清理时间稍微延迟一下，让JavaScript脚本先执行，清理时也不会一下全部清理掉所有的垃圾，会根据按需进行清理直至所有垃圾都回收完毕，然后继续等待下个GC标记阶段执行结束。</p><h4 id="并发回收" tabindex="-1">并发回收 <a class="header-anchor" href="#并发回收" aria-label="Permalink to &quot;并发回收&quot;">​</a></h4><p>虽然增量标记和惰性清理的出现使主线程停顿时间大大减少了，但是总体的停顿时间其实并未减少，如果真正细算起来甚至还增加了，应用程序的吞吐量也被降低，不过用户和浏览器的交互体验大大提升牺牲也是值得的。但是后续V8团队为了使回收更加高效， 又使用了并发回收机制，他是在主线程在执行程序任务时，主动开启辅助线程进行GC回收。而主线程又可以自由执行而不会挂起(标记操作全部由辅助进程操作)。</p><p>![image-20240918144121902](/Users/leviliu/Library/Application Support/typora-user-images/image-20240918144121902.png)</p><h2 id="巧用弱引用" tabindex="-1">巧用弱引用 <a class="header-anchor" href="#巧用弱引用" aria-label="Permalink to &quot;巧用弱引用&quot;">​</a></h2><p>在ES6中为我们新增了两个有效的数据结构<code>WeakMap</code>和<code>WeakSet</code>，就是为了解决内存泄漏的问题而诞生的。其表示<code>弱引用</code>，它的键名所引用的对象均是弱引用，弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，只要所引用的对象没有其他的引用了，垃圾回收机制就会释放该对象所占用的内存。这也就意味着我们不需要关心<code>WeakMap</code>中键名对其他对象的引用，也不需要手动地进行引用清除，我们尝试在node中演示一下过程(参考阮一峰ES6标准入门中的示例，自己手动实现了一遍)。</p><p>首先打开node命令行，输入以下命令：</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --expose-gc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> //</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --expose-gc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 表示允许手动执行垃圾回收机制</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>然后我们执行下面的代码。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 手动执行一次垃圾回收保证内存数据准确</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> global.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">undefined</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 查看当前占用的内存，主要关心heapUsed字段，大小约为4.4MB</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memoryUsage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rss</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21626880</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  heapTotal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7585792</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  heapUsed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4708440</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  external</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8710</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个WeakMap</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeakMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">undefined</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个数组并赋值给变量key</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">undefined</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将WeakMap的键名指向该数组</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 此时该数组存在两个引用，一个是key，一个是WeakMap的键名</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注意WeakMap是弱引用</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WeakMap { [items unknown] }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 手动执行一次垃圾回收</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> global.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">undefined</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 再次查看内存占用大小，heapUsed已经增加到约12MB</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memoryUsage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rss</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30232576</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  heapTotal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17694720</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  heapUsed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13068464</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  external</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8688</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 手动清除变量key对数组的引用</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注意这里并没有清除WeakMap中键名对数组的引用</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 再次执行垃圾回收</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> global.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">undefined</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 查看内存占用大小，发现heapUsed已经回到了之前的大小(这里约为4.8M，原来为4.4M，稍微有些浮动)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> process.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memoryUsage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rss</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22110208</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  heapTotal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9158656</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  heapUsed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5089752</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  external</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8698</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><p>在上述示例中，我们发现虽然我们没有手动清除<code>WeakMap</code>中的键名对数组的引用，但是内存依旧已经回到原始的大小，说明该数组已经被回收，那么这个也就是弱引用的具体含义了。</p><h2 id="文献参考" tabindex="-1">文献参考 <a class="header-anchor" href="#文献参考" aria-label="Permalink to &quot;文献参考&quot;">​</a></h2><p><a href="https://juejin.cn/post/6844904016325902344?searchId=202409141613204E388F3833596F2257BB" target="_blank" rel="noreferrer">https://juejin.cn/post/6844904016325902344?searchId=202409141613204E388F3833596F2257BB</a></p><p><a href="https://juejin.cn/post/7194781956389732389?searchId=202409141631351FB350840955661E770C" target="_blank" rel="noreferrer">https://juejin.cn/post/7194781956389732389?searchId=202409141631351FB350840955661E770C</a></p><p><a href="https://muyacode.github.io/FrontEndLearnNotes/Document/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86#%E6%96%B0%E7%94%9F%E4%BB%A3" target="_blank" rel="noreferrer">https://muyacode.github.io/FrontEndLearnNotes/Document/计算机基础/操作系统知识#新生代</a></p>',82)]))}]]);export{l as __pageData,e as default};
