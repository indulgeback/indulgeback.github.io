import{_ as e,c as a,G as t,b as r}from"./chunks/framework.BrC0DRXd.js";const l=JSON.parse('{"title":"性能优化之requestAnimationFrame与requestIdleCallback","description":"介绍了requestAnimationFrame与requestIdleCallback的用法和适用场景","frontmatter":{"title":"性能优化之requestAnimationFrame与requestIdleCallback","date":"2023-09-29T00:00:00.000Z","author":"liuwy","categories":["JavaScript"],"tags":["性能优化"],"description":"介绍了requestAnimationFrame与requestIdleCallback的用法和适用场景","articleGPT":"介绍了requestAnimationFrame与requestIdleCallback的用法和适用场景，包括动画实现方式、为什么使用requestAnimationFrame、requestIdleCallback的适用场景和不适合的场景。","head":[["link",{"rel":"canonical","href":"https://blog.imsyy.top/posts/技术内功/3、性能优化之requestAnimationFrame与requestIdleCallback"}]]},"headers":[],"relativePath":"posts/技术内功/3、性能优化之requestAnimationFrame与requestIdleCallback.md","filePath":"posts/技术内功/3、性能优化之requestAnimationFrame与requestIdleCallback.md","lastUpdated":1740135853000}');const i=e({name:"posts/技术内功/3、性能优化之requestAnimationFrame与requestIdleCallback.md"},[["render",function(e,l,i,o,n,s){return r(),a("div",null,l[0]||(l[0]=[t('<h1 id="性能优化之requestanimationframe与requestidlecallback" tabindex="-1">性能优化之requestAnimationFrame与requestIdleCallback <a class="header-anchor" href="#性能优化之requestanimationframe与requestidlecallback" aria-label="Permalink to &quot;性能优化之requestAnimationFrame与requestIdleCallback&quot;">​</a></h1><h2 id="requestanimationframe" tabindex="-1">requestAnimationFrame <a class="header-anchor" href="#requestanimationframe" aria-label="Permalink to &quot;requestAnimationFrame&quot;">​</a></h2><p>MDN链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame</a></p><p><strong><code>window.requestAnimationFrame()</code></strong> 方法会告诉浏览器你希望执行一个动画。它要求浏览器在下一次重绘之前，调用用户提供的回调函数。</p><h3 id="动画实现方式" tabindex="-1">动画实现方式 <a class="header-anchor" href="#动画实现方式" aria-label="Permalink to &quot;动画实现方式&quot;">​</a></h3><ul><li>CSS动画</li><li>JS动画 <ul><li>定时器实现</li><li>canvas加定时器实现</li><li>requestAnimationFrame</li></ul></li><li>SVG动画</li></ul><h3 id="为什么使用requestanimationframe" tabindex="-1">为什么使用requestAnimationFrame <a class="header-anchor" href="#为什么使用requestanimationframe" aria-label="Permalink to &quot;为什么使用requestAnimationFrame&quot;">​</a></h3><p>因为使用定时器去做动画，动画会发生抖动</p><p>而使用requestAnimationFrame去做动画则不会</p><h3 id="为什么使用requestanimationframe动画不会卡顿" tabindex="-1">为什么使用requestAnimationFrame动画不会卡顿 <a class="header-anchor" href="#为什么使用requestanimationframe动画不会卡顿" aria-label="Permalink to &quot;为什么使用requestAnimationFrame动画不会卡顿&quot;">​</a></h3><p>其实所有的前端性能问题我们都可以在浏览器渲染流程中的某个阶段找到原因，在JS的执行逻辑中，会存在浏览器的时间循环这个机制（大家可以去自行了解一下这个机制，已经很耳熟能详了），而当我们使用定时器去做动画的时候，定时器任务会被放置到计时器队列（属于宏任务队列的一种），属于异步任务，而requestAnimationFrame（下面简称rAF）也同样属于宏任务。</p><p>那么定时器的动画区别又和<code>rAF</code>有什么区别呢？</p><p>本质上就是在于，当到了每次渲染帧之前<code>rAF</code>的回调函数都会去执行，保证了动画<code>尽可能</code>的在每一帧都会去渲染，之所以说尽可能，那是因为如果回调较为复杂，或者由于事件循环的原因赶不上渲染帧的时候，渲染还是会放到下一帧，所以此时也会产生卡顿。</p><p>而使用定时器实现的动画，在浏览器事件循环的过程中，可能事件会慢慢的错乱，因为浏览器的计时器本身就是不精准的，会导致计时越来越不精准，会导致错过大量的渲染帧，或者同一帧变化很大，这也就导致了动画的卡顿或者抖动，而且动画有可能不会在规定时间内完成。</p><p><a class="img-fancybox" href="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c95ba1aa3d144e98f3eb68381a9e226~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" data-fancybox="gallery" data-caption="111.gif"><img class="post-img" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c95ba1aa3d144e98f3eb68381a9e226~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="111.gif" loading="lazy"><span class="post-img-tip">111.gif</span></a></p><h2 id="requestidlecallback" tabindex="-1">requestIdleCallback <a class="header-anchor" href="#requestidlecallback" aria-label="Permalink to &quot;requestIdleCallback&quot;">​</a></h2><p>MDN链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback</a></p><p>React 的 fiber 架构便是受到了requestIdleCallback的启发。</p><p><strong><code>window.requestIdleCallback()</code></strong> 方法插入一个函数，这个函数将在<code>浏览器空闲时期被调用</code>。这使开发者能够在主事件循环上执行后台和低优先级工作，而<code>不会影响延迟关键事件</code>，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间<code>timeout</code>，则有可能为了在超时前执行函数而打乱执行顺序。</p><p>你可以在空闲回调函数中调用 <strong><code>requestIdleCallback()</code></strong>，以便在下一次通过事件循环之前调度另一个回调。</p><ol><li><strong>回调函数</strong>: 回调函数是在主线程空闲时被调用的函数。每次调用时，都会传入一个IdleDeadline对象，该对象提供一个timeRemaining()方法，用来检测当前帧中剩余的空闲时间。</li><li><strong>空闲时间和截止时间（deadline）</strong> : IdleDeadline对象的timeRemaining()方法返回一个DOMHighResTimeStamp，表示在执行回调函数时，在当前帧中剩余多少空闲时间（毫秒）。开发者可以使用这个时间来执行任务，并在时间耗尽前选择适当的时机终止任务，从而避免影响关键渲染或事件处理。</li><li><strong>调度和取消回调</strong>: requestIdleCallback函数安排一个回调函数在主线程下一次空闲时被执行，并返回一个ID，可以用这个ID通过cancelIdleCallback函数取消回调。</li><li><strong>超时</strong>: 你还可以给requestIdleCallback传递一个对象，其中一个属性是timeout，用来指定最长时间（毫秒）。如果任务在指定的时间内尚未执行，即使主线程不空闲，浏览器也会尽量执行回调。</li></ol><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bc9db7aa2a04ae981e11ddf25d6bcd3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=3498&amp;h=1576&amp;s=294858&amp;e=png&amp;b=f8f8f8" data-fancybox="gallery" data-caption="new-thread.png"><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bc9db7aa2a04ae981e11ddf25d6bcd3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=3498&amp;h=1576&amp;s=294858&amp;e=png&amp;b=f8f8f8" alt="new-thread.png" loading="lazy"><span class="post-img-tip">new-thread.png</span></a></p><h3 id="适合的场景" tabindex="-1">适合的场景 <a class="header-anchor" href="#适合的场景" aria-label="Permalink to &quot;适合的场景&quot;">​</a></h3><ol><li><strong>预处理</strong>，例如当你需要处理一些数据，但这些数据不需要立即展示给用户时，可以在空闲时预处理这些数据。</li><li><strong>埋点日志相关</strong>，对于跟踪和分析网站使用情况的代码，通常可以在空闲时执行，以减少影响用户体验的风险。</li><li><strong>延迟执行</strong>: 当你有一些非必须立刻执行的代码时，比如初始化某些非关键的UI组件，你可以使用 requestIdleCallback 来推迟这些任务的执行。</li></ol><p>使用requestIdleCallback的目的是确保关键任务（如处理用户输入、动画等）能够不受干扰地顺滑运行，而将非关键任务推迟到浏览器有足够资源处理它们的时候。这样既提高了页面性能，又优化了用户体验。需要注意的是，并不是所有的后台任务都适合用requestIdleCallback来处理；</p><h3 id="不适合的场景" tabindex="-1">不适合的场景 <a class="header-anchor" href="#不适合的场景" aria-label="Permalink to &quot;不适合的场景&quot;">​</a></h3><ol><li><strong>不适合操作dom&amp;更新UI</strong> 因为执行时机不确定可能导致视觉难以预测，而且requestIdleCallback是在渲染完成才调用的 可能会引发回流重绘。</li><li><strong>不适合做一些耗时的长任务</strong>。虽然是在浏览器空闲执行 但依然运行在主线程上 耗时的长任务同样会导致帧率降低, 造成页面卡顿。</li></ol><h2 id="文献参考" tabindex="-1">文献参考 <a class="header-anchor" href="#文献参考" aria-label="Permalink to &quot;文献参考&quot;">​</a></h2><p>本文非原创，只是对下面的文章做总结</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback</a></p><p><a href="https://juejin.cn/post/7190728064458817591" target="_blank" rel="noreferrer">https://juejin.cn/post/7190728064458817591</a></p><p><a href="https://juejin.cn/post/7350140783548956683" target="_blank" rel="noreferrer">https://juejin.cn/post/7350140783548956683</a></p>',33)]))}]]);export{l as __pageData,i as default};
